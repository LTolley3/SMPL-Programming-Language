\documentclass[10pt]{article}

% Lines beginning with the percent sign are comments
% This file has been commented to help you understand more about LaTeX

% DO NOT EDIT THE LINES BETWEEN THE TWO LONG HORIZONTAL LINES

%---------------------------------------------------------------------------------------------------------

% Packages add extra functionality.
\usepackage{
	times,
	graphicx,
	epstopdf,
	fancyhdr,
	amsfonts,
	amsthm,
	amsmath,
	algorithm,
	algorithmic,
	xspace,
	hyperref}
\usepackage[left=1in,top=1in,right=1in,bottom=1in]{geometry}
\usepackage{sect sty}	%For centering section headings
\usepackage{enumerate}	%Allows more labeling options for enumerate environments 
\usepackage{epsfig}
\usepackage[space]{grffile}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{forest}

% This will set LaTeX to look for figures in the same directory as the .tex file
\graphicspath{.} % The dot means current directory.

\pagestyle{fancy}

\lhead{\YOURID}
\chead{CS334 Final Project Specification}
\rhead{\today}
\lfoot{CSCI 334: Principles of Programming Languages}
\cfoot{\thepage}
\rfoot{Spring 2020}

% Some commands for changing header and footer format
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\headwidth}{\textwidth}
\renewcommand{\footrulewidth}{0.4pt}

% These let you use common environments
\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{observation}{Observation}
\newtheorem{question}{Question}

\setlength{\parindent}{0cm}
\begin{document}
%---------------------------------------------------------------------------------------------------------

% DON'T CHANGE ANYTHING ABOVE HERE

% Edit below as instructed
\newcommand{\YOURID}{Lucas Tolley and Carter Melnick}	% Replace "Your Name Here" with your name
\newcommand{\RRNumber}{3}	% Replace 0 with the actual problem set #
\newcommand{\ProblemHeader}	% Don't change this!



\vspace{\baselineskip}	% Add some vertical space

\begin{enumerate}
	\item
		\emph{Introduction}
		
In some languages (C and Java are two notable examples we’ve dealt with), it can be difficult to make strings do what you want them to do. “Java string” has been typed into my browser so many times that it’s one of my first autocomplete options when I type “j” into google. Our language, Super Simple String Stuff (S4 for short for now, official name pending), will make it much easier to write string manipulation based programs. 
\medskip
In S4, the user won’t have to worry about indexing into char arrays - everything string-related will be string type. The language will also provide useful string methods that may not be present in other languages, such as “middle” or “replace”. We will also try to implement “string arithmetic” to allow users to clearly and precisely modify their strings.

	\item
		\emph{Design Principles}
		
			Strings will be mutable, thought of almost like arrays of characters, that can be manipulated as needed. Programs should be streamlined, so the arrows pass one argument into another seamlessly. Every function falls into one of two categories: Check functions will return true  or false if the given string satisfies the given property. Modify functions will mutate a string in some way, and return a string.
			
	\item
		\emph{Examples}
		\begin{verbatim}
		    
		> Dan replace("an”, "uane”)
        "Duane”
        > Dan anagram() prefix("R”) multiply(3) 
        "RanDRanDRanD”
        > Dan shuffle() tail() shuffle()
        "n”


		\end{verbatim}
		
		Functions to do:
		Substring
		Prepend + append
		
		
	\item
	    \emph{Language Concepts}
	    
	    The user should be familiar with strings and how and why we use them, but does not need to be concerned with the technical way strings are stored and accessed. They should also be familiar with booleans, integers, and conditional statements. As for combining forms, the user should understand piping output from one function into another function, arithmetic operations with strings, and creating functions that modify input or produce new output.
    \item
	    \emph{Syntax}
	    
	    An expression will have a  starting string, and a rule. Rules can be one or more functions that modify the string. Rules either output a string, or end with a check function, which outputs true or false. As of now, our BNF looks like  the following
	    \medskip
	    
% `_'  denotes at least one mandatory white space
%`->'  is a terminal between functions
% `*'  denotes 0 or more
        \begin{verbatim}	    
<start>         ::= <string>_<expr>
<expr>          ::= "NOP"
                | <seq>
                | func
<seq>
<func>          ::= <name> (<variable>*)
<name>          ::= (in list of function names)
<variable>      ::= <number> 
                | <string>
<number>        ::= n in N
	 \end{verbatim}   
	    
	\newpage
	\item
	    \emph{Semantics}

\begin{tabular}{p{1cm}|p{4cm}|p{4cm}|p{5cm}}
    Syntax & Abstract Syntax & Type & Description \\
    \hline
    s e1 & Start(s, e1) & string $\rightarrow$ string * Variable list $\rightarrow$ string & The input string for the program is  passed to the first expression e1, which is a function, along with additional arguments.\\
    \hline
    e1 e2 & Seq(e1,e2) & string * Variable list $\rightarrow$ string * Variable list $\rightarrow$ string & A sequence of two expressions, which are functions. The first function e1 is evaluated, outputs a string, and is passed with the additional variable list to the second function e2.\\
\end{tabular}
	    
	    
	    
	    \begin{enumerate}
	        \item 
	        Our primitives will be strings (represented on the machine as char arrays), integers, and booleans. Integers will primarily be used as inputs to certain functions (such as multiply) and booleans will mainly be outputs of check type functions (like a user-written palindrome function). The user will be able to interact with these types as well as the string type, which we will deal with as a char array in our language implementation.
	        \item
	        The actions of our program fall into one of two categories, as noted before: with a given string, the user can modify it in some way or check it to see if it has some user-defined property. An example of user modification is something like “prefix”, and an example of a check is something like “isUpper”. Methods like “first” and “last” fall into the category of modification. The user can write their own modifying and checking functions.
	        \item Algebraic Data types:
	        \begin{verbatim}

type Variable =
    | String of string
    | Number of int
    
type Expr = 
    | Function of (string * Variable list)
    | Seq of Expr * Expr
    | NOP


\end{verbatim}
	        \item
	        \begin{forest}
	        [replace["Dan"]["an"]["uane"]]
	        \end{forest}
	        \begin{forest}
	        [multiply[prefix[anagram["Dan"]]["R"]][3]]
	        \end{forest}
	        \hspace{2cm}
	        \begin{forest}
	        [shuffle[tail[shuffle["Dan"]]]]
	        \end{forest}
	        \item
	        \begin{enumerate}
	            \item 
	            Programs can read in a string (maybe eventually a file)
	            \item
	            Programs either output a string or a boolean
	            \item
	            Each function that doesn’t return a string can only be used at the end of a function, so any function in the middle of the tree must take in a string and output a string. Functions are evaluated left to right, and return values are passed as arguments to other functions.
	         
	        \end{enumerate}
	    \end{enumerate}
\end{enumerate}


% DO NOT DELETE ANYTHING BELOW THIS LINE
\end{document}